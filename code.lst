Microsoft (R) Macro Assembler Version 14.38.33130.0	    11/13/24 21:03:24
code.asm						     Page 1 - 1


				; Program zawiera wszystkie funkcje do wczytywania i wyswietlania rejestru EAX

				.686
				.model flat
				extern __write : PROC
				extern __read : PROC
				extern _ExitProcess@4 : PROC

				public _main

 00000000			.data
 00000000  0000000C [			obszar db 12 dup (?) ; deklaracja tablicy do przechowywania wprowadzanych cyfr
	    00
	   ]
 0000000C 0000000A			dziesiec dd 10 ; mnożnik
 00000010 00000008			osiem dd 8 ; mnożnik
 00000014 00000002			dwa dd 2 ; mnożnik
 00000018 30 31 32 33 34		dekoder db '0123456789ABCDEF' ; tablica do konwersji na postać szesnastkową
	   35 36 37 38 39
	   41 42 43 44 45
	   46

 00000000			.code
 00000000				wyswietl_EAX PROC
 00000000  60					pusha ; zapisanie rejestrów ogólnych

 00000001  BE 0000000A				mov esi, 10 ; indeks w tablicy 'znaki'
 00000006  BB 0000000A				mov ebx, 10 ; dzielnik równy 10

 0000000B				konwersja:
 0000000B  BA 00000000				mov edx, 0 ; zerowanie starszej części dzielnej
 00000010  F7 F3				div ebx ; dzielenie przez 10, reszta w EDX, iloraz w EAX
 00000012  80 C2 30				add dl, 30H ; zamiana reszty z dzielenia na kod ASCII
 00000015  88 96 00000000 R			mov obszar [esi], dl; zapisanie cyfry w kodzie ASCII
 0000001B  4E					dec esi ; zmniejszenie indeksu
 0000001C  83 F8 00				cmp eax, 0 ; sprawdzenie czy iloraz = 0
 0000001F  75 EA				jne konwersja ; skok, gdy iloraz niezerowy
						
						 ; wypełnienie pozostałych bajtów spacjami i wpisanie znaków nowego wiersza
 00000021				wypeln:
 00000021  0B F6				or esi, esi
 00000023  74 0A				jz wyswietl ; skok, gdy ESI = 0
 00000025  C6 86 00000000 R			mov byte PTR obszar [esi], 20H ; kod spacji
	   20
 0000002C  4E					dec esi ; zmniejszenie indeksu
 0000002D  EB F2				jmp wypeln

 0000002F				wyswietl:
 0000002F  C6 05 00000000 R			mov byte PTR obszar [0], 0AH ; kod nowego wiersza
	   0A
 00000036  C6 05 0000000B R			mov byte PTR obszar [11], 0AH ; kod nowego wiersza
	   0A
						; wyświetlenie cyfr na ekranie
 0000003D  68 0000000C				push dword PTR 12 ; liczba wyświetlanych znaków
 00000042  68 00000000 R			push dword PTR OFFSET obszar ; adres wyśw. obszaru
 00000047  68 00000001				push dword PTR 1; numer urządzenia (ekran ma numer 1)
 0000004C  E8 00000000 E			call __write ; wyświetlenie liczby na ekranie
 00000051  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu

 00000054  61					popa ; przywrócenie rejestrów ogólnych
 00000055  C3					ret ; powrót do miejsca wywołania
 00000056				wyswietl_EAX ENDP

 00000056				wyswietl_EAX_bin PROC
 00000056  60					pusha ; zapisanie rejestrów ogólnych

 00000057  BE 0000000A				mov esi, 10 ; indeks w tablicy 'znaki'
 0000005C  BB 00000002				mov ebx, 2 ; dzielnik równy 10

 00000061				konwersja:
 00000061  BA 00000000				mov edx, 0 ; zerowanie starszej części dzielnej
 00000066  F7 F3				div ebx ; dzielenie przez 10, reszta w EDX, iloraz w EAX
 00000068  80 C2 30				add dl, 30H ; zamiana reszty z dzielenia na kod ASCII
 0000006B  88 96 00000000 R			mov obszar [esi], dl; zapisanie cyfry w kodzie ASCII
 00000071  4E					dec esi ; zmniejszenie indeksu
 00000072  83 F8 00				cmp eax, 0 ; sprawdzenie czy iloraz = 0
 00000075  75 EA				jne konwersja ; skok, gdy iloraz niezerowy
						
						 ; wypełnienie pozostałych bajtów spacjami i wpisanie znaków nowego wiersza
 00000077				wypeln:
 00000077  0B F6				or esi, esi
 00000079  74 0A				jz wyswietl ; skok, gdy ESI = 0
 0000007B  C6 86 00000000 R			mov byte PTR obszar [esi], 20H ; kod spacji
	   20
 00000082  4E					dec esi ; zmniejszenie indeksu
 00000083  EB F2				jmp wypeln

 00000085				wyswietl:
 00000085  C6 05 00000000 R			mov byte PTR obszar [0], 0AH ; kod nowego wiersza
	   0A
 0000008C  C6 05 0000000B R			mov byte PTR obszar [11], 0AH ; kod nowego wiersza
	   0A
						; wyświetlenie cyfr na ekranie
 00000093  68 0000000C				push dword PTR 12 ; liczba wyświetlanych znaków
 00000098  68 00000000 R			push dword PTR OFFSET obszar ; adres wyśw. obszaru
 0000009D  68 00000001				push dword PTR 1; numer urządzenia (ekran ma numer 1)
 000000A2  E8 00000000 E			call __write ; wyświetlenie liczby na ekranie
 000000A7  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu

 000000AA  61					popa ; przywrócenie rejestrów ogólnych
 000000AB  C3					ret ; powrót do miejsca wywołania
 000000AC				wyswietl_EAX_bin ENDP

 000000AC				wyswietl_EAX_oct PROC
 000000AC  60					pusha ; zapisanie rejestrów ogólnych

 000000AD  BE 0000000A				mov esi, 10 ; indeks w tablicy 'znaki'
 000000B2  BB 00000008				mov ebx, 8 ; dzielnik równy 10

 000000B7				konwersja:
 000000B7  BA 00000000				mov edx, 0 ; zerowanie starszej części dzielnej
 000000BC  F7 F3				div ebx ; dzielenie przez 10, reszta w EDX, iloraz w EAX
 000000BE  80 C2 30				add dl, 30H ; zamiana reszty z dzielenia na kod ASCII
 000000C1  88 96 00000000 R			mov obszar [esi], dl; zapisanie cyfry w kodzie ASCII
 000000C7  4E					dec esi ; zmniejszenie indeksu
 000000C8  83 F8 00				cmp eax, 0 ; sprawdzenie czy iloraz = 0
 000000CB  75 EA				jne konwersja ; skok, gdy iloraz niezerowy
						
						 ; wypełnienie pozostałych bajtów spacjami i wpisanie znaków nowego wiersza
 000000CD				wypeln:
 000000CD  0B F6				or esi, esi
 000000CF  74 0A				jz wyswietl ; skok, gdy ESI = 0
 000000D1  C6 86 00000000 R			mov byte PTR obszar [esi], 20H ; kod spacji
	   20
 000000D8  4E					dec esi ; zmniejszenie indeksu
 000000D9  EB F2				jmp wypeln

 000000DB				wyswietl:
 000000DB  C6 05 00000000 R			mov byte PTR obszar [0], 0AH ; kod nowego wiersza
	   0A
 000000E2  C6 05 0000000B R			mov byte PTR obszar [11], 0AH ; kod nowego wiersza
	   0A
						; wyświetlenie cyfr na ekranie
 000000E9  68 0000000C				push dword PTR 12 ; liczba wyświetlanych znaków
 000000EE  68 00000000 R			push dword PTR OFFSET obszar ; adres wyśw. obszaru
 000000F3  68 00000001				push dword PTR 1; numer urządzenia (ekran ma numer 1)
 000000F8  E8 00000000 E			call __write ; wyświetlenie liczby na ekranie
 000000FD  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu

 00000100  61					popa ; przywrócenie rejestrów ogólnych
 00000101  C3					ret ; powrót do miejsca wywołania
 00000102				wyswietl_EAX_oct ENDP


 00000102				wyswietl_EAX_hex PROC
						; wyświetlanie zawartości rejestru EAX
						; w postaci liczby szesnastkowej
 00000102  60					pusha ; przechowanie rejestrów

						; rezerwacja 12 bajtów na stosie (poprzez zmniejszenie
						; rejestru ESP) przeznaczonych na tymczasowe przechowanie
						; cyfr szesnastkowych wyświetlanej liczby
 00000103  83 EC 0C				sub esp, 12
 00000106  8B FC				mov edi, esp ; adres zarezerwowanego obszaru
						; pamięci
						; przygotowanie konwersji
 00000108  B9 00000008				mov ecx, 8 ; liczba obiegów pętli konwersji
 0000010D  BE 00000001				mov esi, 1 ; indeks początkowy używany przy
						; zapisie cyfr
						; pętla konwersji
 00000112					ptl3hex:
						; przesunięcie cykliczne (obrót) rejestru EAX o 4 bity w lewo
						; w szczególności, w pierwszym obiegu pętli bity nr 31 - 28
						; rejestru EAX zostaną przesunięte na pozycje 3 - 0
 00000112  C1 C0 04				rol eax, 4
						; wyodrębnienie 4 najmłodszych bitów i odczytanie z tablicy
						; 'dekoder' odpowiadającej im cyfry w zapisie szesnastkowym
 00000115  8B D8				mov ebx, eax ; kopiowanie EAX do EBX
 00000117  83 E3 0F				and ebx, 0000000FH ; zerowanie bitów 31 - 4 rej.EBX

 0000011A  8A 93 00000018 R			mov dl, dekoder[ebx] ; pobranie cyfry z tablicy
						; przesłanie cyfry do obszaru roboczego
 00000120  88 14 37				mov [edi][esi], dl
 00000123  46					inc esi ;inkrementacja modyfikatora
 00000124  E2 EC				loop ptl3hex ; sterowanie pętlą

						; wpisanie znaku nowego wiersza przed i po cyfrach
 00000126  C6 07 0A				mov byte PTR [edi][0], 10
 00000129  C6 47 09 0A				mov byte PTR [edi][9], 10

						; zamiana zer na spacje
 0000012D  B9 0000000A				mov ecx, 10 ; liczba obiegów pętli
 00000132  BE 00000001				mov esi, 1 ; indeks początkowy
 00000137				ptlzera:
 00000137  80 3C 37 30				cmp byte PTR [edi][esi], 30H ; sprawdzenie czy cyfra to 0
 0000013B  74 02				je byl_zero ; skok, gdy napotkano 0
 0000013D  EB 07				jmp koniec_zer
 0000013F				byl_zero:
 0000013F  C6 04 37 20				mov byte PTR [edi][esi], 20H ; zamiana 0 na spację
 00000143  46					inc esi ; inkrementacja indeksu
 00000144  E2 F1				loop ptlzera ; sterowanie pętlą
 00000146				koniec_zer:

						; wyświetlenie przygotowanych cyfr
 00000146  6A 0A				push 10 ; 8 cyfr + 2 znaki nowego wiersza
 00000148  57					push edi ; adres obszaru roboczego
 00000149  6A 01				push 1 ; nr urządzenia (tu: ekran)
 0000014B  E8 00000000 E			call __write ; wyświetlenie
						; usunięcie ze stosu 24 bajtów, w tym 12 bajtów zapisanych
						; przez 3 rozkazy push przed rozkazem call
						; i 12 bajtów zarezerwowanych na początku podprogramu
 00000150  83 C4 18				add esp, 24

 00000153  61					popa ; odtworzenie rejestrów
 00000154  C3					ret ; powrót z podprogramu
 00000155				wyswietl_EAX_hex ENDP

 00000155				wczytaj_do_EAX PROC
						; zapisanie rejestrów ogólnych na stosie
 00000155  53					push ebx
 00000156  51					push ecx
 00000157  52					push edx
 00000158  56					push esi
 00000159  57					push edi
 0000015A  55					push ebp

						; max ilość znaków wczytywanej liczby
 0000015B  68 0000000C				push dword PTR 12
 00000160  68 00000000 R			push dword PTR OFFSET obszar ; adres obszaru pamięci
 00000165  68 00000000				push dword PTR 0; numer urządzenia (0 dla klawiatury)
 0000016A  E8 00000000 E			call __read ; odczytywanie znaków z klawiatury
						; (dwa znaki podkreślenia przed read)
 0000016F  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu
						; bieżąca wartość przekształcanej liczby przechowywana jest
						; w rejestrze EAX; przyjmujemy 0 jako wartość początkową
 00000172  B8 00000000				mov eax, 0
 00000177  BB 00000000 R			mov ebx, OFFSET obszar ; adres obszaru ze znakami

 0000017C				pobieraj_znaki:
 0000017C  8A 0B				mov cl, [ebx] ; pobranie kolejnej cyfry w kodzie
						; ASCII
 0000017E  43					inc ebx ; zwiększenie indeksu
 0000017F  80 F9 0A				cmp cl,10 ; sprawdzenie czy naciśnięto Enter
 00000182  74 10				je byl_enter ; skok, gdy naciśnięto Enter
 00000184  80 E9 30				sub cl, 30H ; zamiana kodu ASCII na wartość cyfry
 00000187  0F B6 C9				movzx ecx, cl ; przechowanie wartości cyfry w
						; rejestrze ECX
						; mnożenie wcześniej obliczonej wartości razy 10
 0000018A  F7 25 0000000C R			mul dword PTR dziesiec
 00000190  03 C1				add eax, ecx ; dodanie ostatnio odczytanej cyfry
 00000192  EB E8				jmp pobieraj_znaki ; skok na początek pętli

 00000194				byl_enter:

 00000194  5D					pop ebp
 00000195  5F					pop edi
 00000196  5E					pop esi
 00000197  5A					pop edx
 00000198  59					pop ecx
 00000199  5B					pop ebx
 0000019A  C3					ret ; powrót do miejsca wywołania
 0000019B				wczytaj_do_EAX ENDP

 0000019B				wczytaj_do_EAX_bin PROC
						; zapisanie rejestrów ogólnych na stosie
 0000019B  53					push ebx
 0000019C  51					push ecx
 0000019D  52					push edx
 0000019E  56					push esi
 0000019F  57					push edi
 000001A0  55					push ebp

						; max ilość znaków wczytywanej liczby
 000001A1  68 0000000C				push dword PTR 12
 000001A6  68 00000000 R			push dword PTR OFFSET obszar ; adres obszaru pamięci
 000001AB  68 00000000				push dword PTR 0; numer urządzenia (0 dla klawiatury)
 000001B0  E8 00000000 E			call __read ; odczytywanie znaków z klawiatury
						; (dwa znaki podkreślenia przed read)
 000001B5  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu
						; bieżąca wartość przekształcanej liczby przechowywana jest
						; w rejestrze EAX; przyjmujemy 0 jako wartość początkową
 000001B8  B8 00000000				mov eax, 0
 000001BD  BB 00000000 R			mov ebx, OFFSET obszar ; adres obszaru ze znakami

 000001C2				pobieraj_znaki:
 000001C2  8A 0B				mov cl, [ebx] ; pobranie kolejnej cyfry w kodzie
						; ASCII
 000001C4  43					inc ebx ; zwiększenie indeksu
 000001C5  80 F9 0A				cmp cl,10 ; sprawdzenie czy naciśnięto Enter
 000001C8  74 10				je byl_enter ; skok, gdy naciśnięto Enter
 000001CA  80 E9 30				sub cl, 30H ; zamiana kodu ASCII na wartość cyfry
 000001CD  0F B6 C9				movzx ecx, cl ; przechowanie wartości cyfry w
						; rejestrze ECX
						; mnożenie wcześniej obliczonej wartości razy 10
 000001D0  F7 25 00000014 R			mul dword PTR dwa
 000001D6  03 C1				add eax, ecx ; dodanie ostatnio odczytanej cyfry
 000001D8  EB E8				jmp pobieraj_znaki ; skok na początek pętli

 000001DA				byl_enter:

 000001DA  5D					pop ebp
 000001DB  5F					pop edi
 000001DC  5E					pop esi
 000001DD  5A					pop edx
 000001DE  59					pop ecx
 000001DF  5B					pop ebx
 000001E0  C3					ret ; powrót do miejsca wywołania
 000001E1				wczytaj_do_EAX_bin ENDP

 000001E1				wczytaj_do_EAX_oct PROC
						; Zachowanie niektórych rejestrów na stosie
 000001E1  53					push ebx
 000001E2  51					push ecx
 000001E3  52					push edx
 000001E4  56					push esi
 000001E5  57					push edi
 000001E6  55					push ebp

						; max ilość znaków wczytywanej liczby
 000001E7  68 0000000C				push dword PTR 12
 000001EC  68 00000000 R			push dword PTR OFFSET obszar ; adres obszaru pamięci
 000001F1  68 00000000				push dword PTR 0; numer urządzenia (0 dla klawiatury)
 000001F6  E8 00000000 E			call __read ; odczytywanie znaków z klawiatury
						; (dwa znaki podkreślenia przed read)
 000001FB  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu
						; bieżąca wartość przekształcanej liczby przechowywana jest
						; w rejestrze EAX; przyjmujemy 0 jako wartość początkową
 000001FE  B8 00000000				mov eax, 0
 00000203  BB 00000000 R			mov ebx, OFFSET obszar ; adres obszaru ze znakami

 00000208				pobieraj_znaki_oct:
 00000208  8A 0B				mov cl, [ebx] ; pobranie kolejnej cyfry w kodzie
						; ASCII
 0000020A  43					inc ebx ; zwiększenie indeksu
 0000020B  80 F9 0A				cmp cl,10 ; sprawdzenie czy naciśnięto Enter
 0000020E  74 10				je byl_enter_oct ; skok, gdy naciśnięto Enter
 00000210  80 E9 30				sub cl, 30H ; zamiana kodu ASCII na wartość cyfry
 00000213  0F B6 C9				movzx ecx, cl ; przechowanie wartości cyfry w
						; rejestrze ECX
						; mnożenie wcześniej obliczonej wartości razy 10
 00000216  F7 25 00000010 R			mul dword PTR osiem
 0000021C  03 C1				add eax, ecx ; dodanie ostatnio odczytanej cyfry
 0000021E  EB E8				jmp pobieraj_znaki_oct ; skok na początek pętli

 00000220				byl_enter_oct:
 00000220  5D					pop ebp                      ; Przywrócenie rejestrów
 00000221  5F					pop edi
 00000222  5E					pop esi
 00000223  5A					pop edx
 00000224  59					pop ecx
 00000225  5B					pop ebx
 00000226  C3					ret                          ; Powrót z procedury
 00000227				wczytaj_do_EAX_oct ENDP

 00000227				wczytaj_do_EAX_hex PROC
						; wczytywanie liczby szesnastkowej z klawiatury – liczba po
						; konwersji na postać binarną zostaje wpisana do rejestru EAX
						; po wprowadzeniu ostatniej cyfry należy nacisnąć klawisz
						; Enter
 00000227  53					push ebx
 00000228  51					push ecx
 00000229  52					push edx
 0000022A  56					push esi
 0000022B  57					push edi
 0000022C  55					push ebp
						; rezerwacja 12 bajtów na stosie przeznaczonych na tymczasowe
						; przechowanie cyfr szesnastkowych wyświetlanej liczby
 0000022D  83 EC 0C				sub esp, 12 ; rezerwacja poprzez zmniejszenie ESP
 00000230  8B F4				mov esi, esp ; adres zarezerwowanego obszaru pamięci
 00000232  68 0000000A				push dword PTR 10 ; max ilość znaków wczytyw. liczby
 00000237  56					push esi ; adres obszaru pamięci
 00000238  68 00000000				push dword PTR 0; numer urządzenia (0 dla klawiatury)
 0000023D  E8 00000000 E			call __read ; odczytywanie znaków z klawiatury
						; (dwa znaki podkreślenia przed read)
 00000242  83 C4 0C				add esp, 12 ; usunięcie parametrów ze stosu
 00000245  B8 00000000				mov eax, 0 ; dotychczas uzyskany wynik
 0000024A				pocz_konw:
 0000024A  8A 16				mov dl, [esi] ; pobranie kolejnego bajtu
 0000024C  46					inc esi ; inkrementacja indeksu
 0000024D  80 FA 0A				cmp dl, 10 ; sprawdzenie czy naciśnięto Enter
 00000250  74 32				je gotowe ; skok do końca podprogramu
						; sprawdzenie czy wprowadzony znak jest cyfrą 0, 1, 2 , ..., 9
 00000252  80 FA 30				cmp dl, '0'
 00000255  72 F3				jb pocz_konw ; inny znak jest ignorowany
 00000257  80 FA 39				cmp dl, '9'
 0000025A  77 0A				ja sprawdzaj_dalej
 0000025C  80 EA 30				sub dl, '0' ; zamiana kodu ASCII na wartość cyfry
 0000025F				dopisz:
 0000025F  C1 E0 04				shl eax, 4 ; przesunięcie logiczne w lewo o 4 bity
 00000262  0A C2				or al, dl ; dopisanie utworzonego kodu 4-bitowego
						; na 4 ostatnie bity rejestru EAX
 00000264  EB E4				jmp pocz_konw ; skok na początek pętli konwersji
						; sprawdzenie czy wprowadzony znak jest cyfrą A, B, ..., F
 00000266				sprawdzaj_dalej:
 00000266  80 FA 41				cmp dl, 'A'
 00000269  72 DF				jb pocz_konw ; inny znak jest ignorowany
 0000026B  80 FA 46				cmp dl, 'F'
 0000026E  77 05				ja sprawdzaj_dalej2
 00000270  80 EA 37				sub dl, 'A' - 10 ; wyznaczenie kodu binarnego
 00000273  EB EA				jmp dopisz

					; sprawdzenie czy wprowadzony znak jest cyfrą a, b, ..., f
 00000275				sprawdzaj_dalej2:
 00000275  80 FA 61				cmp dl, 'a'
 00000278  72 D0				jb pocz_konw ; inny znak jest ignorowany
 0000027A  80 FA 66				cmp dl, 'f'
 0000027D  77 CB				ja pocz_konw ; inny znak jest ignorowany
 0000027F  80 EA 57				sub dl, 'a' - 10
 00000282  EB DB				jmp dopisz

 00000284				gotowe:
					; zwolnienie zarezerwowanego obszaru pamięci
 00000284  83 C4 0C				add esp, 12
 00000287  5D					pop ebp
 00000288  5F					pop edi
 00000289  5E					pop esi
 0000028A  5A					pop edx
 0000028B  59					pop ecx
 0000028C  5B					pop ebx
 0000028D  C3					ret
 0000028E				wczytaj_do_EAX_hex ENDP

 0000028E				_main PROC
 0000028E  E8 FFFFFF08				call wczytaj_do_EAX_bin
 00000293  E8 FFFFFD68				call wyswietl_EAX
 00000298  E8 FFFFFDB9				call wyswietl_EAX_bin
 0000029D  E8 FFFFFE0A				call wyswietl_EAX_oct
 000002A2  E8 FFFFFE5B				call wyswietl_EAX_hex


 000002A7  6A 00				push 0
 000002A9  E8 00000000 E			call _ExitProcess@4
 000002AE				_main ENDP

				END

Microsoft (R) Macro Assembler Version 14.38.33130.0	    11/13/24 21:03:24
code.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 00000028 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000002AE Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

_main  . . . . . . . . . . . . .	P Near	 0000028E _TEXT	Length= 00000020 Public
wczytaj_do_EAX_bin . . . . . . .	P Near	 0000019B _TEXT	Length= 00000046 Public
  pobieraj_znaki . . . . . . . .	L Near	 000001C2 _TEXT	
  byl_enter  . . . . . . . . . .	L Near	 000001DA _TEXT	
wczytaj_do_EAX_hex . . . . . . .	P Near	 00000227 _TEXT	Length= 00000067 Public
  pocz_konw  . . . . . . . . . .	L Near	 0000024A _TEXT	
  dopisz . . . . . . . . . . . .	L Near	 0000025F _TEXT	
  sprawdzaj_dalej  . . . . . . .	L Near	 00000266 _TEXT	
  sprawdzaj_dalej2 . . . . . . .	L Near	 00000275 _TEXT	
  gotowe . . . . . . . . . . . .	L Near	 00000284 _TEXT	
wczytaj_do_EAX_oct . . . . . . .	P Near	 000001E1 _TEXT	Length= 00000046 Public
  pobieraj_znaki_oct . . . . . .	L Near	 00000208 _TEXT	
  byl_enter_oct  . . . . . . . .	L Near	 00000220 _TEXT	
wczytaj_do_EAX . . . . . . . . .	P Near	 00000155 _TEXT	Length= 00000046 Public
  pobieraj_znaki . . . . . . . .	L Near	 0000017C _TEXT	
  byl_enter  . . . . . . . . . .	L Near	 00000194 _TEXT	
wyswietl_EAX_bin . . . . . . . .	P Near	 00000056 _TEXT	Length= 00000056 Public
  konwersja  . . . . . . . . . .	L Near	 00000061 _TEXT	
  wypeln . . . . . . . . . . . .	L Near	 00000077 _TEXT	
  wyswietl . . . . . . . . . . .	L Near	 00000085 _TEXT	
wyswietl_EAX_hex . . . . . . . .	P Near	 00000102 _TEXT	Length= 00000053 Public
  ptl3hex  . . . . . . . . . . .	L Near	 00000112 _TEXT	
  ptlzera  . . . . . . . . . . .	L Near	 00000137 _TEXT	
  byl_zero . . . . . . . . . . .	L Near	 0000013F _TEXT	
  koniec_zer . . . . . . . . . .	L Near	 00000146 _TEXT	
wyswietl_EAX_oct . . . . . . . .	P Near	 000000AC _TEXT	Length= 00000056 Public
  konwersja  . . . . . . . . . .	L Near	 000000B7 _TEXT	
  wypeln . . . . . . . . . . . .	L Near	 000000CD _TEXT	
  wyswietl . . . . . . . . . . .	L Near	 000000DB _TEXT	
wyswietl_EAX . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000056 Public
  konwersja  . . . . . . . . . .	L Near	 0000000B _TEXT	
  wypeln . . . . . . . . . . . .	L Near	 00000021 _TEXT	
  wyswietl . . . . . . . . . . .	L Near	 0000002F _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_ExitProcess@4 . . . . . . . . .	L Near	 00000000 FLAT	External
__read . . . . . . . . . . . . .	L Near	 00000000 FLAT	External
__write  . . . . . . . . . . . .	L Near	 00000000 FLAT	External
dekoder  . . . . . . . . . . . .	Byte	 00000018 _DATA	
dwa  . . . . . . . . . . . . . .	DWord	 00000014 _DATA	
dziesiec . . . . . . . . . . . .	DWord	 0000000C _DATA	
obszar . . . . . . . . . . . . .	Byte	 00000000 _DATA	
osiem  . . . . . . . . . . . . .	DWord	 00000010 _DATA	

	   0 Warnings
	   0 Errors
